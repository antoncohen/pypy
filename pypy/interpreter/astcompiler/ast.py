# Generated by tools/asdl_py.py
from pypy.interpreter.error import OperationError
from rpython.tool.pairtype import extendabletype
from pypy.interpreter.baseobjspace import W_Root
from pypy.interpreter import typedef
from pypy.interpreter.gateway import interp2app
from rpython.tool.sourcetools import func_with_new_name


class AST(object):
    __metaclass__ = extendabletype

    def walkabout(self, visitor):
        raise AssertionError("walkabout() implementation not provided")

    def mutate_over(self, visitor):
        raise AssertionError("mutate_over() implementation not provided")


class NodeVisitorNotImplemented(Exception):
    pass


class _FieldsWrapper(W_Root):
    "Hack around the fact we can't store tuples on a TypeDef."

    def __init__(self, fields):
        self.fields = fields

    def __spacebind__(self, space):
        return space.newtuple([space.wrap(field) for field in self.fields])


class W_AST(W_Root):
    w_dict = None

    def getdict(self, space):
        if self.w_dict is None:
            self.w_dict = space.newdict(instance=True)
        return self.w_dict

    def reduce_w(self, space):
        w_dict = self.w_dict
        if w_dict is None:
            w_dict = space.newdict()
        w_type = space.type(self)
        w_fields = w_type.getdictvalue(space, "_fields")
        for w_name in space.fixedview(w_fields):
            space.setitem(w_dict, w_name,
                          space.getattr(self, w_name))
        w_attrs = space.findattr(w_type, space.wrap("_attributes"))
        if w_attrs:
            for w_name in space.fixedview(w_attrs):
                space.setitem(w_dict, w_name,
                              space.getattr(self, w_name))
        return space.newtuple([space.type(self),
                               space.newtuple([]),
                               w_dict])

    def setstate_w(self, space, w_state):
        for w_name in space.unpackiterable(w_state):
            space.setattr(self, w_name,
                          space.getitem(w_state, w_name))

def get_W_AST_new(node_class):
    def generic_W_AST_new(space, w_type, __args__):
        node = space.allocate_instance(node_class, w_type)
        return space.wrap(node)
    return func_with_new_name(generic_W_AST_new, "new_%s" % node_class.__name__)


def W_AST_init(space, w_self, __args__):
    args_w, kwargs_w = __args__.unpack()
    if args_w and len(args_w) != 0:
        w_err = space.wrap("_ast.AST constructor takes 0 positional arguments")
        raise OperationError(space.w_TypeError, w_err)
    for field, w_value in kwargs_w.iteritems():
        space.setattr(w_self, space.wrap(field), w_value)


W_AST.typedef = typedef.TypeDef("AST",
    _fields=_FieldsWrapper([]),
    _attributes=_FieldsWrapper([]),
    __module__='_ast',
    __reduce__=interp2app(W_AST.reduce_w),
    __setstate__=interp2app(W_AST.setstate_w),
    __dict__ = typedef.GetSetProperty(typedef.descr_get_dict,
                                      typedef.descr_set_dict, cls=W_AST),
    __new__=interp2app(get_W_AST_new(W_AST)),
    __init__=interp2app(W_AST_init),
)

class State:
    AST_TYPES = []

    @classmethod
    def ast_type(cls, name, base):
        cls.AST_TYPES.append((name, base))

    def __init__(self, space):
        self.w_AST = space.gettypeobject(W_AST.typedef)
        for (name, base) in self.AST_TYPES:
            self.make_new_type(space, name, base)
        
    def make_new_type(self, space, name, base):
        w_base = getattr(self, 'w_%s' % base)
        w_type = space.call_function(
            space.w_type, 
            space.wrap(name), space.newtuple([w_base]), space.newdict())
        setattr(self, 'w_%s' % name, w_type)

def get(space):
    return space.fromcache(State)

class mod(AST):
    pass
State.ast_type('mod', 'AST')

class Module(mod):

    def __init__(self, body):
        self.body = body

    def walkabout(self, visitor):
        visitor.visit_Module(self)

    def mutate_over(self, visitor):
        if self.body:
            visitor._mutate_sequence(self.body)
        return visitor.visit_Module(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Module)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        return w_node
State.ast_type('Module', 'mod')


class Interactive(mod):

    def __init__(self, body):
        self.body = body

    def walkabout(self, visitor):
        visitor.visit_Interactive(self)

    def mutate_over(self, visitor):
        if self.body:
            visitor._mutate_sequence(self.body)
        return visitor.visit_Interactive(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Interactive)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        return w_node
State.ast_type('Interactive', 'mod')


class Expression(mod):

    def __init__(self, body):
        self.body = body

    def walkabout(self, visitor):
        visitor.visit_Expression(self)

    def mutate_over(self, visitor):
        self.body = self.body.mutate_over(visitor)
        return visitor.visit_Expression(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Expression)
        w_body = self.body.to_object(space)  # expr
        space.setattr(w_node, space.wrap('body'), w_body)
        return w_node
State.ast_type('Expression', 'mod')


class Suite(mod):

    def __init__(self, body):
        self.body = body

    def walkabout(self, visitor):
        visitor.visit_Suite(self)

    def mutate_over(self, visitor):
        if self.body:
            visitor._mutate_sequence(self.body)
        return visitor.visit_Suite(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Suite)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        return w_node
State.ast_type('Suite', 'mod')


class stmt(AST):

    def __init__(self, lineno, col_offset):
        self.lineno = lineno
        self.col_offset = col_offset
State.ast_type('stmt', 'AST')

class FunctionDef(stmt):

    def __init__(self, name, args, body, decorator_list, lineno, col_offset):
        self.name = name
        self.args = args
        self.body = body
        self.decorator_list = decorator_list
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_FunctionDef(self)

    def mutate_over(self, visitor):
        self.args = self.args.mutate_over(visitor)
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.decorator_list:
            visitor._mutate_sequence(self.decorator_list)
        return visitor.visit_FunctionDef(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_FunctionDef)
        w_name = space.wrap(self.name)  # identifier
        space.setattr(w_node, space.wrap('name'), w_name)
        w_args = self.args.to_object(space)  # arguments
        space.setattr(w_node, space.wrap('args'), w_args)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        if self.decorator_list is None:
            decorator_list_w = []
        else:
            decorator_list_w = [node.to_object(space) for node in self.decorator_list] # expr
        w_decorator_list = space.newlist(decorator_list_w)
        space.setattr(w_node, space.wrap('decorator_list'), w_decorator_list)
        return w_node
State.ast_type('FunctionDef', 'stmt')


class ClassDef(stmt):

    def __init__(self, name, bases, body, decorator_list, lineno, col_offset):
        self.name = name
        self.bases = bases
        self.body = body
        self.decorator_list = decorator_list
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_ClassDef(self)

    def mutate_over(self, visitor):
        if self.bases:
            visitor._mutate_sequence(self.bases)
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.decorator_list:
            visitor._mutate_sequence(self.decorator_list)
        return visitor.visit_ClassDef(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_ClassDef)
        w_name = space.wrap(self.name)  # identifier
        space.setattr(w_node, space.wrap('name'), w_name)
        if self.bases is None:
            bases_w = []
        else:
            bases_w = [node.to_object(space) for node in self.bases] # expr
        w_bases = space.newlist(bases_w)
        space.setattr(w_node, space.wrap('bases'), w_bases)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        if self.decorator_list is None:
            decorator_list_w = []
        else:
            decorator_list_w = [node.to_object(space) for node in self.decorator_list] # expr
        w_decorator_list = space.newlist(decorator_list_w)
        space.setattr(w_node, space.wrap('decorator_list'), w_decorator_list)
        return w_node
State.ast_type('ClassDef', 'stmt')


class Return(stmt):

    def __init__(self, value, lineno, col_offset):
        self.value = value
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Return(self)

    def mutate_over(self, visitor):
        if self.value:
            self.value = self.value.mutate_over(visitor)
        return visitor.visit_Return(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Return)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        return w_node
State.ast_type('Return', 'stmt')


class Delete(stmt):

    def __init__(self, targets, lineno, col_offset):
        self.targets = targets
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Delete(self)

    def mutate_over(self, visitor):
        if self.targets:
            visitor._mutate_sequence(self.targets)
        return visitor.visit_Delete(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Delete)
        if self.targets is None:
            targets_w = []
        else:
            targets_w = [node.to_object(space) for node in self.targets] # expr
        w_targets = space.newlist(targets_w)
        space.setattr(w_node, space.wrap('targets'), w_targets)
        return w_node
State.ast_type('Delete', 'stmt')


class Assign(stmt):

    def __init__(self, targets, value, lineno, col_offset):
        self.targets = targets
        self.value = value
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Assign(self)

    def mutate_over(self, visitor):
        if self.targets:
            visitor._mutate_sequence(self.targets)
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_Assign(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Assign)
        if self.targets is None:
            targets_w = []
        else:
            targets_w = [node.to_object(space) for node in self.targets] # expr
        w_targets = space.newlist(targets_w)
        space.setattr(w_node, space.wrap('targets'), w_targets)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        return w_node
State.ast_type('Assign', 'stmt')


class AugAssign(stmt):

    def __init__(self, target, op, value, lineno, col_offset):
        self.target = target
        self.op = op
        self.value = value
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_AugAssign(self)

    def mutate_over(self, visitor):
        self.target = self.target.mutate_over(visitor)
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_AugAssign(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_AugAssign)
        w_target = self.target.to_object(space)  # expr
        space.setattr(w_node, space.wrap('target'), w_target)
        w_op = operator_to_class[self.op - 1]().to_object(space)  # operator
        space.setattr(w_node, space.wrap('op'), w_op)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        return w_node
State.ast_type('AugAssign', 'stmt')


class Print(stmt):

    def __init__(self, dest, values, nl, lineno, col_offset):
        self.dest = dest
        self.values = values
        self.nl = nl
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Print(self)

    def mutate_over(self, visitor):
        if self.dest:
            self.dest = self.dest.mutate_over(visitor)
        if self.values:
            visitor._mutate_sequence(self.values)
        return visitor.visit_Print(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Print)
        w_dest = self.dest.to_object(space)  # expr
        space.setattr(w_node, space.wrap('dest'), w_dest)
        if self.values is None:
            values_w = []
        else:
            values_w = [node.to_object(space) for node in self.values] # expr
        w_values = space.newlist(values_w)
        space.setattr(w_node, space.wrap('values'), w_values)
        w_nl = self.nl.to_object(space)  # bool
        space.setattr(w_node, space.wrap('nl'), w_nl)
        return w_node
State.ast_type('Print', 'stmt')


class For(stmt):

    def __init__(self, target, iter, body, orelse, lineno, col_offset):
        self.target = target
        self.iter = iter
        self.body = body
        self.orelse = orelse
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_For(self)

    def mutate_over(self, visitor):
        self.target = self.target.mutate_over(visitor)
        self.iter = self.iter.mutate_over(visitor)
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.orelse:
            visitor._mutate_sequence(self.orelse)
        return visitor.visit_For(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_For)
        w_target = self.target.to_object(space)  # expr
        space.setattr(w_node, space.wrap('target'), w_target)
        w_iter = self.iter.to_object(space)  # expr
        space.setattr(w_node, space.wrap('iter'), w_iter)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        if self.orelse is None:
            orelse_w = []
        else:
            orelse_w = [node.to_object(space) for node in self.orelse] # stmt
        w_orelse = space.newlist(orelse_w)
        space.setattr(w_node, space.wrap('orelse'), w_orelse)
        return w_node
State.ast_type('For', 'stmt')


class While(stmt):

    def __init__(self, test, body, orelse, lineno, col_offset):
        self.test = test
        self.body = body
        self.orelse = orelse
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_While(self)

    def mutate_over(self, visitor):
        self.test = self.test.mutate_over(visitor)
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.orelse:
            visitor._mutate_sequence(self.orelse)
        return visitor.visit_While(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_While)
        w_test = self.test.to_object(space)  # expr
        space.setattr(w_node, space.wrap('test'), w_test)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        if self.orelse is None:
            orelse_w = []
        else:
            orelse_w = [node.to_object(space) for node in self.orelse] # stmt
        w_orelse = space.newlist(orelse_w)
        space.setattr(w_node, space.wrap('orelse'), w_orelse)
        return w_node
State.ast_type('While', 'stmt')


class If(stmt):

    def __init__(self, test, body, orelse, lineno, col_offset):
        self.test = test
        self.body = body
        self.orelse = orelse
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_If(self)

    def mutate_over(self, visitor):
        self.test = self.test.mutate_over(visitor)
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.orelse:
            visitor._mutate_sequence(self.orelse)
        return visitor.visit_If(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_If)
        w_test = self.test.to_object(space)  # expr
        space.setattr(w_node, space.wrap('test'), w_test)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        if self.orelse is None:
            orelse_w = []
        else:
            orelse_w = [node.to_object(space) for node in self.orelse] # stmt
        w_orelse = space.newlist(orelse_w)
        space.setattr(w_node, space.wrap('orelse'), w_orelse)
        return w_node
State.ast_type('If', 'stmt')


class With(stmt):

    def __init__(self, context_expr, optional_vars, body, lineno, col_offset):
        self.context_expr = context_expr
        self.optional_vars = optional_vars
        self.body = body
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_With(self)

    def mutate_over(self, visitor):
        self.context_expr = self.context_expr.mutate_over(visitor)
        if self.optional_vars:
            self.optional_vars = self.optional_vars.mutate_over(visitor)
        if self.body:
            visitor._mutate_sequence(self.body)
        return visitor.visit_With(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_With)
        w_context_expr = self.context_expr.to_object(space)  # expr
        space.setattr(w_node, space.wrap('context_expr'), w_context_expr)
        w_optional_vars = self.optional_vars.to_object(space)  # expr
        space.setattr(w_node, space.wrap('optional_vars'), w_optional_vars)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        return w_node
State.ast_type('With', 'stmt')


class Raise(stmt):

    def __init__(self, type, inst, tback, lineno, col_offset):
        self.type = type
        self.inst = inst
        self.tback = tback
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Raise(self)

    def mutate_over(self, visitor):
        if self.type:
            self.type = self.type.mutate_over(visitor)
        if self.inst:
            self.inst = self.inst.mutate_over(visitor)
        if self.tback:
            self.tback = self.tback.mutate_over(visitor)
        return visitor.visit_Raise(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Raise)
        w_type = self.type.to_object(space)  # expr
        space.setattr(w_node, space.wrap('type'), w_type)
        w_inst = self.inst.to_object(space)  # expr
        space.setattr(w_node, space.wrap('inst'), w_inst)
        w_tback = self.tback.to_object(space)  # expr
        space.setattr(w_node, space.wrap('tback'), w_tback)
        return w_node
State.ast_type('Raise', 'stmt')


class TryExcept(stmt):

    def __init__(self, body, handlers, orelse, lineno, col_offset):
        self.body = body
        self.handlers = handlers
        self.orelse = orelse
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_TryExcept(self)

    def mutate_over(self, visitor):
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.handlers:
            visitor._mutate_sequence(self.handlers)
        if self.orelse:
            visitor._mutate_sequence(self.orelse)
        return visitor.visit_TryExcept(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_TryExcept)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        if self.handlers is None:
            handlers_w = []
        else:
            handlers_w = [node.to_object(space) for node in self.handlers] # excepthandler
        w_handlers = space.newlist(handlers_w)
        space.setattr(w_node, space.wrap('handlers'), w_handlers)
        if self.orelse is None:
            orelse_w = []
        else:
            orelse_w = [node.to_object(space) for node in self.orelse] # stmt
        w_orelse = space.newlist(orelse_w)
        space.setattr(w_node, space.wrap('orelse'), w_orelse)
        return w_node
State.ast_type('TryExcept', 'stmt')


class TryFinally(stmt):

    def __init__(self, body, finalbody, lineno, col_offset):
        self.body = body
        self.finalbody = finalbody
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_TryFinally(self)

    def mutate_over(self, visitor):
        if self.body:
            visitor._mutate_sequence(self.body)
        if self.finalbody:
            visitor._mutate_sequence(self.finalbody)
        return visitor.visit_TryFinally(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_TryFinally)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        if self.finalbody is None:
            finalbody_w = []
        else:
            finalbody_w = [node.to_object(space) for node in self.finalbody] # stmt
        w_finalbody = space.newlist(finalbody_w)
        space.setattr(w_node, space.wrap('finalbody'), w_finalbody)
        return w_node
State.ast_type('TryFinally', 'stmt')


class Assert(stmt):

    def __init__(self, test, msg, lineno, col_offset):
        self.test = test
        self.msg = msg
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Assert(self)

    def mutate_over(self, visitor):
        self.test = self.test.mutate_over(visitor)
        if self.msg:
            self.msg = self.msg.mutate_over(visitor)
        return visitor.visit_Assert(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Assert)
        w_test = self.test.to_object(space)  # expr
        space.setattr(w_node, space.wrap('test'), w_test)
        w_msg = self.msg.to_object(space)  # expr
        space.setattr(w_node, space.wrap('msg'), w_msg)
        return w_node
State.ast_type('Assert', 'stmt')


class Import(stmt):

    def __init__(self, names, lineno, col_offset):
        self.names = names
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Import(self)

    def mutate_over(self, visitor):
        if self.names:
            visitor._mutate_sequence(self.names)
        return visitor.visit_Import(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Import)
        if self.names is None:
            names_w = []
        else:
            names_w = [node.to_object(space) for node in self.names] # alias
        w_names = space.newlist(names_w)
        space.setattr(w_node, space.wrap('names'), w_names)
        return w_node
State.ast_type('Import', 'stmt')


class ImportFrom(stmt):

    def __init__(self, module, names, level, lineno, col_offset):
        self.module = module
        self.names = names
        self.level = level
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_ImportFrom(self)

    def mutate_over(self, visitor):
        if self.names:
            visitor._mutate_sequence(self.names)
        return visitor.visit_ImportFrom(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_ImportFrom)
        w_module = space.wrap(self.module)  # identifier
        space.setattr(w_node, space.wrap('module'), w_module)
        if self.names is None:
            names_w = []
        else:
            names_w = [node.to_object(space) for node in self.names] # alias
        w_names = space.newlist(names_w)
        space.setattr(w_node, space.wrap('names'), w_names)
        w_level = space.wrap(self.level)  # int
        space.setattr(w_node, space.wrap('level'), w_level)
        return w_node
State.ast_type('ImportFrom', 'stmt')


class Exec(stmt):

    def __init__(self, body, globals, locals, lineno, col_offset):
        self.body = body
        self.globals = globals
        self.locals = locals
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Exec(self)

    def mutate_over(self, visitor):
        self.body = self.body.mutate_over(visitor)
        if self.globals:
            self.globals = self.globals.mutate_over(visitor)
        if self.locals:
            self.locals = self.locals.mutate_over(visitor)
        return visitor.visit_Exec(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Exec)
        w_body = self.body.to_object(space)  # expr
        space.setattr(w_node, space.wrap('body'), w_body)
        w_globals = self.globals.to_object(space)  # expr
        space.setattr(w_node, space.wrap('globals'), w_globals)
        w_locals = self.locals.to_object(space)  # expr
        space.setattr(w_node, space.wrap('locals'), w_locals)
        return w_node
State.ast_type('Exec', 'stmt')


class Global(stmt):

    def __init__(self, names, lineno, col_offset):
        self.names = names
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Global(self)

    def mutate_over(self, visitor):
        return visitor.visit_Global(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Global)
        if self.names is None:
            names_w = []
        else:
            names_w = [space.wrap(node) for node in self.names] # identifier
        w_names = space.newlist(names_w)
        space.setattr(w_node, space.wrap('names'), w_names)
        return w_node
State.ast_type('Global', 'stmt')


class Expr(stmt):

    def __init__(self, value, lineno, col_offset):
        self.value = value
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Expr(self)

    def mutate_over(self, visitor):
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_Expr(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Expr)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        return w_node
State.ast_type('Expr', 'stmt')


class Pass(stmt):

    def __init__(self, lineno, col_offset):
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Pass(self)

    def mutate_over(self, visitor):
        return visitor.visit_Pass(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Pass)
        return w_node
State.ast_type('Pass', 'stmt')


class Break(stmt):

    def __init__(self, lineno, col_offset):
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Break(self)

    def mutate_over(self, visitor):
        return visitor.visit_Break(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Break)
        return w_node
State.ast_type('Break', 'stmt')


class Continue(stmt):

    def __init__(self, lineno, col_offset):
        stmt.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Continue(self)

    def mutate_over(self, visitor):
        return visitor.visit_Continue(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Continue)
        return w_node
State.ast_type('Continue', 'stmt')


class expr(AST):

    def __init__(self, lineno, col_offset):
        self.lineno = lineno
        self.col_offset = col_offset
State.ast_type('expr', 'AST')

class BoolOp(expr):

    def __init__(self, op, values, lineno, col_offset):
        self.op = op
        self.values = values
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_BoolOp(self)

    def mutate_over(self, visitor):
        if self.values:
            visitor._mutate_sequence(self.values)
        return visitor.visit_BoolOp(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_BoolOp)
        w_op = boolop_to_class[self.op - 1]().to_object(space)  # boolop
        space.setattr(w_node, space.wrap('op'), w_op)
        if self.values is None:
            values_w = []
        else:
            values_w = [node.to_object(space) for node in self.values] # expr
        w_values = space.newlist(values_w)
        space.setattr(w_node, space.wrap('values'), w_values)
        return w_node
State.ast_type('BoolOp', 'expr')


class BinOp(expr):

    def __init__(self, left, op, right, lineno, col_offset):
        self.left = left
        self.op = op
        self.right = right
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_BinOp(self)

    def mutate_over(self, visitor):
        self.left = self.left.mutate_over(visitor)
        self.right = self.right.mutate_over(visitor)
        return visitor.visit_BinOp(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_BinOp)
        w_left = self.left.to_object(space)  # expr
        space.setattr(w_node, space.wrap('left'), w_left)
        w_op = operator_to_class[self.op - 1]().to_object(space)  # operator
        space.setattr(w_node, space.wrap('op'), w_op)
        w_right = self.right.to_object(space)  # expr
        space.setattr(w_node, space.wrap('right'), w_right)
        return w_node
State.ast_type('BinOp', 'expr')


class UnaryOp(expr):

    def __init__(self, op, operand, lineno, col_offset):
        self.op = op
        self.operand = operand
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_UnaryOp(self)

    def mutate_over(self, visitor):
        self.operand = self.operand.mutate_over(visitor)
        return visitor.visit_UnaryOp(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_UnaryOp)
        w_op = unaryop_to_class[self.op - 1]().to_object(space)  # unaryop
        space.setattr(w_node, space.wrap('op'), w_op)
        w_operand = self.operand.to_object(space)  # expr
        space.setattr(w_node, space.wrap('operand'), w_operand)
        return w_node
State.ast_type('UnaryOp', 'expr')


class Lambda(expr):

    def __init__(self, args, body, lineno, col_offset):
        self.args = args
        self.body = body
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Lambda(self)

    def mutate_over(self, visitor):
        self.args = self.args.mutate_over(visitor)
        self.body = self.body.mutate_over(visitor)
        return visitor.visit_Lambda(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Lambda)
        w_args = self.args.to_object(space)  # arguments
        space.setattr(w_node, space.wrap('args'), w_args)
        w_body = self.body.to_object(space)  # expr
        space.setattr(w_node, space.wrap('body'), w_body)
        return w_node
State.ast_type('Lambda', 'expr')


class IfExp(expr):

    def __init__(self, test, body, orelse, lineno, col_offset):
        self.test = test
        self.body = body
        self.orelse = orelse
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_IfExp(self)

    def mutate_over(self, visitor):
        self.test = self.test.mutate_over(visitor)
        self.body = self.body.mutate_over(visitor)
        self.orelse = self.orelse.mutate_over(visitor)
        return visitor.visit_IfExp(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_IfExp)
        w_test = self.test.to_object(space)  # expr
        space.setattr(w_node, space.wrap('test'), w_test)
        w_body = self.body.to_object(space)  # expr
        space.setattr(w_node, space.wrap('body'), w_body)
        w_orelse = self.orelse.to_object(space)  # expr
        space.setattr(w_node, space.wrap('orelse'), w_orelse)
        return w_node
State.ast_type('IfExp', 'expr')


class Dict(expr):

    def __init__(self, keys, values, lineno, col_offset):
        self.keys = keys
        self.values = values
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Dict(self)

    def mutate_over(self, visitor):
        if self.keys:
            visitor._mutate_sequence(self.keys)
        if self.values:
            visitor._mutate_sequence(self.values)
        return visitor.visit_Dict(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Dict)
        if self.keys is None:
            keys_w = []
        else:
            keys_w = [node.to_object(space) for node in self.keys] # expr
        w_keys = space.newlist(keys_w)
        space.setattr(w_node, space.wrap('keys'), w_keys)
        if self.values is None:
            values_w = []
        else:
            values_w = [node.to_object(space) for node in self.values] # expr
        w_values = space.newlist(values_w)
        space.setattr(w_node, space.wrap('values'), w_values)
        return w_node
State.ast_type('Dict', 'expr')


class Set(expr):

    def __init__(self, elts, lineno, col_offset):
        self.elts = elts
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Set(self)

    def mutate_over(self, visitor):
        if self.elts:
            visitor._mutate_sequence(self.elts)
        return visitor.visit_Set(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Set)
        if self.elts is None:
            elts_w = []
        else:
            elts_w = [node.to_object(space) for node in self.elts] # expr
        w_elts = space.newlist(elts_w)
        space.setattr(w_node, space.wrap('elts'), w_elts)
        return w_node
State.ast_type('Set', 'expr')


class ListComp(expr):

    def __init__(self, elt, generators, lineno, col_offset):
        self.elt = elt
        self.generators = generators
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_ListComp(self)

    def mutate_over(self, visitor):
        self.elt = self.elt.mutate_over(visitor)
        if self.generators:
            visitor._mutate_sequence(self.generators)
        return visitor.visit_ListComp(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_ListComp)
        w_elt = self.elt.to_object(space)  # expr
        space.setattr(w_node, space.wrap('elt'), w_elt)
        if self.generators is None:
            generators_w = []
        else:
            generators_w = [node.to_object(space) for node in self.generators] # comprehension
        w_generators = space.newlist(generators_w)
        space.setattr(w_node, space.wrap('generators'), w_generators)
        return w_node
State.ast_type('ListComp', 'expr')


class SetComp(expr):

    def __init__(self, elt, generators, lineno, col_offset):
        self.elt = elt
        self.generators = generators
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_SetComp(self)

    def mutate_over(self, visitor):
        self.elt = self.elt.mutate_over(visitor)
        if self.generators:
            visitor._mutate_sequence(self.generators)
        return visitor.visit_SetComp(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_SetComp)
        w_elt = self.elt.to_object(space)  # expr
        space.setattr(w_node, space.wrap('elt'), w_elt)
        if self.generators is None:
            generators_w = []
        else:
            generators_w = [node.to_object(space) for node in self.generators] # comprehension
        w_generators = space.newlist(generators_w)
        space.setattr(w_node, space.wrap('generators'), w_generators)
        return w_node
State.ast_type('SetComp', 'expr')


class DictComp(expr):

    def __init__(self, key, value, generators, lineno, col_offset):
        self.key = key
        self.value = value
        self.generators = generators
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_DictComp(self)

    def mutate_over(self, visitor):
        self.key = self.key.mutate_over(visitor)
        self.value = self.value.mutate_over(visitor)
        if self.generators:
            visitor._mutate_sequence(self.generators)
        return visitor.visit_DictComp(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_DictComp)
        w_key = self.key.to_object(space)  # expr
        space.setattr(w_node, space.wrap('key'), w_key)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        if self.generators is None:
            generators_w = []
        else:
            generators_w = [node.to_object(space) for node in self.generators] # comprehension
        w_generators = space.newlist(generators_w)
        space.setattr(w_node, space.wrap('generators'), w_generators)
        return w_node
State.ast_type('DictComp', 'expr')


class GeneratorExp(expr):

    def __init__(self, elt, generators, lineno, col_offset):
        self.elt = elt
        self.generators = generators
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_GeneratorExp(self)

    def mutate_over(self, visitor):
        self.elt = self.elt.mutate_over(visitor)
        if self.generators:
            visitor._mutate_sequence(self.generators)
        return visitor.visit_GeneratorExp(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_GeneratorExp)
        w_elt = self.elt.to_object(space)  # expr
        space.setattr(w_node, space.wrap('elt'), w_elt)
        if self.generators is None:
            generators_w = []
        else:
            generators_w = [node.to_object(space) for node in self.generators] # comprehension
        w_generators = space.newlist(generators_w)
        space.setattr(w_node, space.wrap('generators'), w_generators)
        return w_node
State.ast_type('GeneratorExp', 'expr')


class Yield(expr):

    def __init__(self, value, lineno, col_offset):
        self.value = value
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Yield(self)

    def mutate_over(self, visitor):
        if self.value:
            self.value = self.value.mutate_over(visitor)
        return visitor.visit_Yield(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Yield)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        return w_node
State.ast_type('Yield', 'expr')


class Compare(expr):

    def __init__(self, left, ops, comparators, lineno, col_offset):
        self.left = left
        self.ops = ops
        self.comparators = comparators
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Compare(self)

    def mutate_over(self, visitor):
        self.left = self.left.mutate_over(visitor)
        if self.comparators:
            visitor._mutate_sequence(self.comparators)
        return visitor.visit_Compare(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Compare)
        w_left = self.left.to_object(space)  # expr
        space.setattr(w_node, space.wrap('left'), w_left)
        if self.ops is None:
            ops_w = []
        else:
            ops_w = [cmpop_to_class[node - 1]().to_object(space) for node in self.ops] # cmpop
        w_ops = space.newlist(ops_w)
        space.setattr(w_node, space.wrap('ops'), w_ops)
        if self.comparators is None:
            comparators_w = []
        else:
            comparators_w = [node.to_object(space) for node in self.comparators] # expr
        w_comparators = space.newlist(comparators_w)
        space.setattr(w_node, space.wrap('comparators'), w_comparators)
        return w_node
State.ast_type('Compare', 'expr')


class Call(expr):

    def __init__(self, func, args, keywords, starargs, kwargs, lineno, col_offset):
        self.func = func
        self.args = args
        self.keywords = keywords
        self.starargs = starargs
        self.kwargs = kwargs
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Call(self)

    def mutate_over(self, visitor):
        self.func = self.func.mutate_over(visitor)
        if self.args:
            visitor._mutate_sequence(self.args)
        if self.keywords:
            visitor._mutate_sequence(self.keywords)
        if self.starargs:
            self.starargs = self.starargs.mutate_over(visitor)
        if self.kwargs:
            self.kwargs = self.kwargs.mutate_over(visitor)
        return visitor.visit_Call(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Call)
        w_func = self.func.to_object(space)  # expr
        space.setattr(w_node, space.wrap('func'), w_func)
        if self.args is None:
            args_w = []
        else:
            args_w = [node.to_object(space) for node in self.args] # expr
        w_args = space.newlist(args_w)
        space.setattr(w_node, space.wrap('args'), w_args)
        if self.keywords is None:
            keywords_w = []
        else:
            keywords_w = [node.to_object(space) for node in self.keywords] # keyword
        w_keywords = space.newlist(keywords_w)
        space.setattr(w_node, space.wrap('keywords'), w_keywords)
        w_starargs = self.starargs.to_object(space)  # expr
        space.setattr(w_node, space.wrap('starargs'), w_starargs)
        w_kwargs = self.kwargs.to_object(space)  # expr
        space.setattr(w_node, space.wrap('kwargs'), w_kwargs)
        return w_node
State.ast_type('Call', 'expr')


class Repr(expr):

    def __init__(self, value, lineno, col_offset):
        self.value = value
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Repr(self)

    def mutate_over(self, visitor):
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_Repr(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Repr)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        return w_node
State.ast_type('Repr', 'expr')


class Num(expr):

    def __init__(self, n, lineno, col_offset):
        self.n = n
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Num(self)

    def mutate_over(self, visitor):
        return visitor.visit_Num(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Num)
        w_n = self.n  # object
        space.setattr(w_node, space.wrap('n'), w_n)
        return w_node
State.ast_type('Num', 'expr')


class Str(expr):

    def __init__(self, s, lineno, col_offset):
        self.s = s
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Str(self)

    def mutate_over(self, visitor):
        return visitor.visit_Str(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Str)
        w_s = self.s  # string
        space.setattr(w_node, space.wrap('s'), w_s)
        return w_node
State.ast_type('Str', 'expr')


class Attribute(expr):

    def __init__(self, value, attr, ctx, lineno, col_offset):
        self.value = value
        self.attr = attr
        self.ctx = ctx
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Attribute(self)

    def mutate_over(self, visitor):
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_Attribute(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Attribute)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        w_attr = space.wrap(self.attr)  # identifier
        space.setattr(w_node, space.wrap('attr'), w_attr)
        w_ctx = expr_context_to_class[self.ctx - 1]().to_object(space)  # expr_context
        space.setattr(w_node, space.wrap('ctx'), w_ctx)
        return w_node
State.ast_type('Attribute', 'expr')


class Subscript(expr):

    def __init__(self, value, slice, ctx, lineno, col_offset):
        self.value = value
        self.slice = slice
        self.ctx = ctx
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Subscript(self)

    def mutate_over(self, visitor):
        self.value = self.value.mutate_over(visitor)
        self.slice = self.slice.mutate_over(visitor)
        return visitor.visit_Subscript(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Subscript)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        w_slice = self.slice.to_object(space)  # slice
        space.setattr(w_node, space.wrap('slice'), w_slice)
        w_ctx = expr_context_to_class[self.ctx - 1]().to_object(space)  # expr_context
        space.setattr(w_node, space.wrap('ctx'), w_ctx)
        return w_node
State.ast_type('Subscript', 'expr')


class Name(expr):

    def __init__(self, id, ctx, lineno, col_offset):
        self.id = id
        self.ctx = ctx
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Name(self)

    def mutate_over(self, visitor):
        return visitor.visit_Name(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Name)
        w_id = space.wrap(self.id)  # identifier
        space.setattr(w_node, space.wrap('id'), w_id)
        w_ctx = expr_context_to_class[self.ctx - 1]().to_object(space)  # expr_context
        space.setattr(w_node, space.wrap('ctx'), w_ctx)
        return w_node
State.ast_type('Name', 'expr')


class List(expr):

    def __init__(self, elts, ctx, lineno, col_offset):
        self.elts = elts
        self.ctx = ctx
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_List(self)

    def mutate_over(self, visitor):
        if self.elts:
            visitor._mutate_sequence(self.elts)
        return visitor.visit_List(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_List)
        if self.elts is None:
            elts_w = []
        else:
            elts_w = [node.to_object(space) for node in self.elts] # expr
        w_elts = space.newlist(elts_w)
        space.setattr(w_node, space.wrap('elts'), w_elts)
        w_ctx = expr_context_to_class[self.ctx - 1]().to_object(space)  # expr_context
        space.setattr(w_node, space.wrap('ctx'), w_ctx)
        return w_node
State.ast_type('List', 'expr')


class Tuple(expr):

    def __init__(self, elts, ctx, lineno, col_offset):
        self.elts = elts
        self.ctx = ctx
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Tuple(self)

    def mutate_over(self, visitor):
        if self.elts:
            visitor._mutate_sequence(self.elts)
        return visitor.visit_Tuple(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Tuple)
        if self.elts is None:
            elts_w = []
        else:
            elts_w = [node.to_object(space) for node in self.elts] # expr
        w_elts = space.newlist(elts_w)
        space.setattr(w_node, space.wrap('elts'), w_elts)
        w_ctx = expr_context_to_class[self.ctx - 1]().to_object(space)  # expr_context
        space.setattr(w_node, space.wrap('ctx'), w_ctx)
        return w_node
State.ast_type('Tuple', 'expr')


class Const(expr):

    def __init__(self, value, lineno, col_offset):
        self.value = value
        expr.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_Const(self)

    def mutate_over(self, visitor):
        return visitor.visit_Const(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Const)
        w_value = self.value  # object
        space.setattr(w_node, space.wrap('value'), w_value)
        return w_node
State.ast_type('Const', 'expr')


class expr_context(AST):
    pass
State.ast_type('expr_context', 'AST')

class _Load(expr_context):
    def to_object(self, space):
        return space.call_function(get(space).w_Load)
State.ast_type('Load', 'expr_context')

class _Store(expr_context):
    def to_object(self, space):
        return space.call_function(get(space).w_Store)
State.ast_type('Store', 'expr_context')

class _Del(expr_context):
    def to_object(self, space):
        return space.call_function(get(space).w_Del)
State.ast_type('Del', 'expr_context')

class _AugLoad(expr_context):
    def to_object(self, space):
        return space.call_function(get(space).w_AugLoad)
State.ast_type('AugLoad', 'expr_context')

class _AugStore(expr_context):
    def to_object(self, space):
        return space.call_function(get(space).w_AugStore)
State.ast_type('AugStore', 'expr_context')

class _Param(expr_context):
    def to_object(self, space):
        return space.call_function(get(space).w_Param)
State.ast_type('Param', 'expr_context')

Load = 1
Store = 2
Del = 3
AugLoad = 4
AugStore = 5
Param = 6

expr_context_to_class = [
    _Load,
    _Store,
    _Del,
    _AugLoad,
    _AugStore,
    _Param,
]

class slice(AST):
    pass
State.ast_type('slice', 'AST')

class Ellipsis(slice):


    def walkabout(self, visitor):
        visitor.visit_Ellipsis(self)

    def mutate_over(self, visitor):
        return visitor.visit_Ellipsis(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Ellipsis)
        return w_node
State.ast_type('Ellipsis', 'slice')


class Slice(slice):

    def __init__(self, lower, upper, step):
        self.lower = lower
        self.upper = upper
        self.step = step

    def walkabout(self, visitor):
        visitor.visit_Slice(self)

    def mutate_over(self, visitor):
        if self.lower:
            self.lower = self.lower.mutate_over(visitor)
        if self.upper:
            self.upper = self.upper.mutate_over(visitor)
        if self.step:
            self.step = self.step.mutate_over(visitor)
        return visitor.visit_Slice(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Slice)
        w_lower = self.lower.to_object(space)  # expr
        space.setattr(w_node, space.wrap('lower'), w_lower)
        w_upper = self.upper.to_object(space)  # expr
        space.setattr(w_node, space.wrap('upper'), w_upper)
        w_step = self.step.to_object(space)  # expr
        space.setattr(w_node, space.wrap('step'), w_step)
        return w_node
State.ast_type('Slice', 'slice')


class ExtSlice(slice):

    def __init__(self, dims):
        self.dims = dims

    def walkabout(self, visitor):
        visitor.visit_ExtSlice(self)

    def mutate_over(self, visitor):
        if self.dims:
            visitor._mutate_sequence(self.dims)
        return visitor.visit_ExtSlice(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_ExtSlice)
        if self.dims is None:
            dims_w = []
        else:
            dims_w = [node.to_object(space) for node in self.dims] # slice
        w_dims = space.newlist(dims_w)
        space.setattr(w_node, space.wrap('dims'), w_dims)
        return w_node
State.ast_type('ExtSlice', 'slice')


class Index(slice):

    def __init__(self, value):
        self.value = value

    def walkabout(self, visitor):
        visitor.visit_Index(self)

    def mutate_over(self, visitor):
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_Index(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_Index)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        return w_node
State.ast_type('Index', 'slice')


class boolop(AST):
    pass
State.ast_type('boolop', 'AST')

class _And(boolop):
    def to_object(self, space):
        return space.call_function(get(space).w_And)
State.ast_type('And', 'boolop')

class _Or(boolop):
    def to_object(self, space):
        return space.call_function(get(space).w_Or)
State.ast_type('Or', 'boolop')

And = 1
Or = 2

boolop_to_class = [
    _And,
    _Or,
]

class operator(AST):
    pass
State.ast_type('operator', 'AST')

class _Add(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_Add)
State.ast_type('Add', 'operator')

class _Sub(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_Sub)
State.ast_type('Sub', 'operator')

class _Mult(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_Mult)
State.ast_type('Mult', 'operator')

class _Div(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_Div)
State.ast_type('Div', 'operator')

class _Mod(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_Mod)
State.ast_type('Mod', 'operator')

class _Pow(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_Pow)
State.ast_type('Pow', 'operator')

class _LShift(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_LShift)
State.ast_type('LShift', 'operator')

class _RShift(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_RShift)
State.ast_type('RShift', 'operator')

class _BitOr(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_BitOr)
State.ast_type('BitOr', 'operator')

class _BitXor(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_BitXor)
State.ast_type('BitXor', 'operator')

class _BitAnd(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_BitAnd)
State.ast_type('BitAnd', 'operator')

class _FloorDiv(operator):
    def to_object(self, space):
        return space.call_function(get(space).w_FloorDiv)
State.ast_type('FloorDiv', 'operator')

Add = 1
Sub = 2
Mult = 3
Div = 4
Mod = 5
Pow = 6
LShift = 7
RShift = 8
BitOr = 9
BitXor = 10
BitAnd = 11
FloorDiv = 12

operator_to_class = [
    _Add,
    _Sub,
    _Mult,
    _Div,
    _Mod,
    _Pow,
    _LShift,
    _RShift,
    _BitOr,
    _BitXor,
    _BitAnd,
    _FloorDiv,
]

class unaryop(AST):
    pass
State.ast_type('unaryop', 'AST')

class _Invert(unaryop):
    def to_object(self, space):
        return space.call_function(get(space).w_Invert)
State.ast_type('Invert', 'unaryop')

class _Not(unaryop):
    def to_object(self, space):
        return space.call_function(get(space).w_Not)
State.ast_type('Not', 'unaryop')

class _UAdd(unaryop):
    def to_object(self, space):
        return space.call_function(get(space).w_UAdd)
State.ast_type('UAdd', 'unaryop')

class _USub(unaryop):
    def to_object(self, space):
        return space.call_function(get(space).w_USub)
State.ast_type('USub', 'unaryop')

Invert = 1
Not = 2
UAdd = 3
USub = 4

unaryop_to_class = [
    _Invert,
    _Not,
    _UAdd,
    _USub,
]

class cmpop(AST):
    pass
State.ast_type('cmpop', 'AST')

class _Eq(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_Eq)
State.ast_type('Eq', 'cmpop')

class _NotEq(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_NotEq)
State.ast_type('NotEq', 'cmpop')

class _Lt(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_Lt)
State.ast_type('Lt', 'cmpop')

class _LtE(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_LtE)
State.ast_type('LtE', 'cmpop')

class _Gt(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_Gt)
State.ast_type('Gt', 'cmpop')

class _GtE(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_GtE)
State.ast_type('GtE', 'cmpop')

class _Is(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_Is)
State.ast_type('Is', 'cmpop')

class _IsNot(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_IsNot)
State.ast_type('IsNot', 'cmpop')

class _In(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_In)
State.ast_type('In', 'cmpop')

class _NotIn(cmpop):
    def to_object(self, space):
        return space.call_function(get(space).w_NotIn)
State.ast_type('NotIn', 'cmpop')

Eq = 1
NotEq = 2
Lt = 3
LtE = 4
Gt = 5
GtE = 6
Is = 7
IsNot = 8
In = 9
NotIn = 10

cmpop_to_class = [
    _Eq,
    _NotEq,
    _Lt,
    _LtE,
    _Gt,
    _GtE,
    _Is,
    _IsNot,
    _In,
    _NotIn,
]

class comprehension(AST):

    def __init__(self, target, iter, ifs):
        self.target = target
        self.iter = iter
        self.ifs = ifs

    def mutate_over(self, visitor):
        self.target = self.target.mutate_over(visitor)
        self.iter = self.iter.mutate_over(visitor)
        if self.ifs:
            visitor._mutate_sequence(self.ifs)
        return visitor.visit_comprehension(self)

    def walkabout(self, visitor):
        visitor.visit_comprehension(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_comprehension)
        w_target = self.target.to_object(space)  # expr
        space.setattr(w_node, space.wrap('target'), w_target)
        w_iter = self.iter.to_object(space)  # expr
        space.setattr(w_node, space.wrap('iter'), w_iter)
        if self.ifs is None:
            ifs_w = []
        else:
            ifs_w = [node.to_object(space) for node in self.ifs] # expr
        w_ifs = space.newlist(ifs_w)
        space.setattr(w_node, space.wrap('ifs'), w_ifs)
        return w_node
State.ast_type('comprehension', 'AST')

class excepthandler(AST):

    def __init__(self, lineno, col_offset):
        self.lineno = lineno
        self.col_offset = col_offset
State.ast_type('excepthandler', 'AST')

class ExceptHandler(excepthandler):

    def __init__(self, type, name, body, lineno, col_offset):
        self.type = type
        self.name = name
        self.body = body
        excepthandler.__init__(self, lineno, col_offset)

    def walkabout(self, visitor):
        visitor.visit_ExceptHandler(self)

    def mutate_over(self, visitor):
        if self.type:
            self.type = self.type.mutate_over(visitor)
        if self.name:
            self.name = self.name.mutate_over(visitor)
        if self.body:
            visitor._mutate_sequence(self.body)
        return visitor.visit_ExceptHandler(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_ExceptHandler)
        w_type = self.type.to_object(space)  # expr
        space.setattr(w_node, space.wrap('type'), w_type)
        w_name = self.name.to_object(space)  # expr
        space.setattr(w_node, space.wrap('name'), w_name)
        if self.body is None:
            body_w = []
        else:
            body_w = [node.to_object(space) for node in self.body] # stmt
        w_body = space.newlist(body_w)
        space.setattr(w_node, space.wrap('body'), w_body)
        return w_node
State.ast_type('ExceptHandler', 'excepthandler')


class arguments(AST):

    def __init__(self, args, vararg, kwarg, defaults):
        self.args = args
        self.vararg = vararg
        self.kwarg = kwarg
        self.defaults = defaults

    def mutate_over(self, visitor):
        if self.args:
            visitor._mutate_sequence(self.args)
        if self.defaults:
            visitor._mutate_sequence(self.defaults)
        return visitor.visit_arguments(self)

    def walkabout(self, visitor):
        visitor.visit_arguments(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_arguments)
        if self.args is None:
            args_w = []
        else:
            args_w = [node.to_object(space) for node in self.args] # expr
        w_args = space.newlist(args_w)
        space.setattr(w_node, space.wrap('args'), w_args)
        w_vararg = space.wrap(self.vararg)  # identifier
        space.setattr(w_node, space.wrap('vararg'), w_vararg)
        w_kwarg = space.wrap(self.kwarg)  # identifier
        space.setattr(w_node, space.wrap('kwarg'), w_kwarg)
        if self.defaults is None:
            defaults_w = []
        else:
            defaults_w = [node.to_object(space) for node in self.defaults] # expr
        w_defaults = space.newlist(defaults_w)
        space.setattr(w_node, space.wrap('defaults'), w_defaults)
        return w_node
State.ast_type('arguments', 'AST')

class keyword(AST):

    def __init__(self, arg, value):
        self.arg = arg
        self.value = value

    def mutate_over(self, visitor):
        self.value = self.value.mutate_over(visitor)
        return visitor.visit_keyword(self)

    def walkabout(self, visitor):
        visitor.visit_keyword(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_keyword)
        w_arg = space.wrap(self.arg)  # identifier
        space.setattr(w_node, space.wrap('arg'), w_arg)
        w_value = self.value.to_object(space)  # expr
        space.setattr(w_node, space.wrap('value'), w_value)
        return w_node
State.ast_type('keyword', 'AST')

class alias(AST):

    def __init__(self, name, asname):
        self.name = name
        self.asname = asname

    def mutate_over(self, visitor):
        return visitor.visit_alias(self)

    def walkabout(self, visitor):
        visitor.visit_alias(self)

    def to_object(self, space):
        w_node = space.call_function(get(space).w_alias)
        w_name = space.wrap(self.name)  # identifier
        space.setattr(w_node, space.wrap('name'), w_name)
        w_asname = space.wrap(self.asname)  # identifier
        space.setattr(w_node, space.wrap('asname'), w_asname)
        return w_node
State.ast_type('alias', 'AST')

class ASTVisitor(object):

    def visit_sequence(self, seq):
        if seq is not None:
            for node in seq:
                node.walkabout(self)

    def default_visitor(self, node):
        raise NodeVisitorNotImplemented

    def _mutate_sequence(self, seq):
        for i in range(len(seq)):
            seq[i] = seq[i].mutate_over(self)

    def visit_Module(self, node):
        return self.default_visitor(node)
    def visit_Interactive(self, node):
        return self.default_visitor(node)
    def visit_Expression(self, node):
        return self.default_visitor(node)
    def visit_Suite(self, node):
        return self.default_visitor(node)
    def visit_FunctionDef(self, node):
        return self.default_visitor(node)
    def visit_ClassDef(self, node):
        return self.default_visitor(node)
    def visit_Return(self, node):
        return self.default_visitor(node)
    def visit_Delete(self, node):
        return self.default_visitor(node)
    def visit_Assign(self, node):
        return self.default_visitor(node)
    def visit_AugAssign(self, node):
        return self.default_visitor(node)
    def visit_Print(self, node):
        return self.default_visitor(node)
    def visit_For(self, node):
        return self.default_visitor(node)
    def visit_While(self, node):
        return self.default_visitor(node)
    def visit_If(self, node):
        return self.default_visitor(node)
    def visit_With(self, node):
        return self.default_visitor(node)
    def visit_Raise(self, node):
        return self.default_visitor(node)
    def visit_TryExcept(self, node):
        return self.default_visitor(node)
    def visit_TryFinally(self, node):
        return self.default_visitor(node)
    def visit_Assert(self, node):
        return self.default_visitor(node)
    def visit_Import(self, node):
        return self.default_visitor(node)
    def visit_ImportFrom(self, node):
        return self.default_visitor(node)
    def visit_Exec(self, node):
        return self.default_visitor(node)
    def visit_Global(self, node):
        return self.default_visitor(node)
    def visit_Expr(self, node):
        return self.default_visitor(node)
    def visit_Pass(self, node):
        return self.default_visitor(node)
    def visit_Break(self, node):
        return self.default_visitor(node)
    def visit_Continue(self, node):
        return self.default_visitor(node)
    def visit_BoolOp(self, node):
        return self.default_visitor(node)
    def visit_BinOp(self, node):
        return self.default_visitor(node)
    def visit_UnaryOp(self, node):
        return self.default_visitor(node)
    def visit_Lambda(self, node):
        return self.default_visitor(node)
    def visit_IfExp(self, node):
        return self.default_visitor(node)
    def visit_Dict(self, node):
        return self.default_visitor(node)
    def visit_Set(self, node):
        return self.default_visitor(node)
    def visit_ListComp(self, node):
        return self.default_visitor(node)
    def visit_SetComp(self, node):
        return self.default_visitor(node)
    def visit_DictComp(self, node):
        return self.default_visitor(node)
    def visit_GeneratorExp(self, node):
        return self.default_visitor(node)
    def visit_Yield(self, node):
        return self.default_visitor(node)
    def visit_Compare(self, node):
        return self.default_visitor(node)
    def visit_Call(self, node):
        return self.default_visitor(node)
    def visit_Repr(self, node):
        return self.default_visitor(node)
    def visit_Num(self, node):
        return self.default_visitor(node)
    def visit_Str(self, node):
        return self.default_visitor(node)
    def visit_Attribute(self, node):
        return self.default_visitor(node)
    def visit_Subscript(self, node):
        return self.default_visitor(node)
    def visit_Name(self, node):
        return self.default_visitor(node)
    def visit_List(self, node):
        return self.default_visitor(node)
    def visit_Tuple(self, node):
        return self.default_visitor(node)
    def visit_Const(self, node):
        return self.default_visitor(node)
    def visit_Ellipsis(self, node):
        return self.default_visitor(node)
    def visit_Slice(self, node):
        return self.default_visitor(node)
    def visit_ExtSlice(self, node):
        return self.default_visitor(node)
    def visit_Index(self, node):
        return self.default_visitor(node)
    def visit_comprehension(self, node):
        return self.default_visitor(node)
    def visit_ExceptHandler(self, node):
        return self.default_visitor(node)
    def visit_arguments(self, node):
        return self.default_visitor(node)
    def visit_keyword(self, node):
        return self.default_visitor(node)
    def visit_alias(self, node):
        return self.default_visitor(node)

class GenericASTVisitor(ASTVisitor):

    def visit_Module(self, node):
        self.visit_sequence(node.body)

    def visit_Interactive(self, node):
        self.visit_sequence(node.body)

    def visit_Expression(self, node):
        node.body.walkabout(self)

    def visit_Suite(self, node):
        self.visit_sequence(node.body)

    def visit_FunctionDef(self, node):
        node.args.walkabout(self)
        self.visit_sequence(node.body)
        self.visit_sequence(node.decorator_list)

    def visit_ClassDef(self, node):
        self.visit_sequence(node.bases)
        self.visit_sequence(node.body)
        self.visit_sequence(node.decorator_list)

    def visit_Return(self, node):
        if node.value:
            node.value.walkabout(self)

    def visit_Delete(self, node):
        self.visit_sequence(node.targets)

    def visit_Assign(self, node):
        self.visit_sequence(node.targets)
        node.value.walkabout(self)

    def visit_AugAssign(self, node):
        node.target.walkabout(self)
        node.value.walkabout(self)

    def visit_Print(self, node):
        if node.dest:
            node.dest.walkabout(self)
        self.visit_sequence(node.values)

    def visit_For(self, node):
        node.target.walkabout(self)
        node.iter.walkabout(self)
        self.visit_sequence(node.body)
        self.visit_sequence(node.orelse)

    def visit_While(self, node):
        node.test.walkabout(self)
        self.visit_sequence(node.body)
        self.visit_sequence(node.orelse)

    def visit_If(self, node):
        node.test.walkabout(self)
        self.visit_sequence(node.body)
        self.visit_sequence(node.orelse)

    def visit_With(self, node):
        node.context_expr.walkabout(self)
        if node.optional_vars:
            node.optional_vars.walkabout(self)
        self.visit_sequence(node.body)

    def visit_Raise(self, node):
        if node.type:
            node.type.walkabout(self)
        if node.inst:
            node.inst.walkabout(self)
        if node.tback:
            node.tback.walkabout(self)

    def visit_TryExcept(self, node):
        self.visit_sequence(node.body)
        self.visit_sequence(node.handlers)
        self.visit_sequence(node.orelse)

    def visit_TryFinally(self, node):
        self.visit_sequence(node.body)
        self.visit_sequence(node.finalbody)

    def visit_Assert(self, node):
        node.test.walkabout(self)
        if node.msg:
            node.msg.walkabout(self)

    def visit_Import(self, node):
        self.visit_sequence(node.names)

    def visit_ImportFrom(self, node):
        self.visit_sequence(node.names)

    def visit_Exec(self, node):
        node.body.walkabout(self)
        if node.globals:
            node.globals.walkabout(self)
        if node.locals:
            node.locals.walkabout(self)

    def visit_Global(self, node):
        pass

    def visit_Expr(self, node):
        node.value.walkabout(self)

    def visit_Pass(self, node):
        pass

    def visit_Break(self, node):
        pass

    def visit_Continue(self, node):
        pass

    def visit_BoolOp(self, node):
        self.visit_sequence(node.values)

    def visit_BinOp(self, node):
        node.left.walkabout(self)
        node.right.walkabout(self)

    def visit_UnaryOp(self, node):
        node.operand.walkabout(self)

    def visit_Lambda(self, node):
        node.args.walkabout(self)
        node.body.walkabout(self)

    def visit_IfExp(self, node):
        node.test.walkabout(self)
        node.body.walkabout(self)
        node.orelse.walkabout(self)

    def visit_Dict(self, node):
        self.visit_sequence(node.keys)
        self.visit_sequence(node.values)

    def visit_Set(self, node):
        self.visit_sequence(node.elts)

    def visit_ListComp(self, node):
        node.elt.walkabout(self)
        self.visit_sequence(node.generators)

    def visit_SetComp(self, node):
        node.elt.walkabout(self)
        self.visit_sequence(node.generators)

    def visit_DictComp(self, node):
        node.key.walkabout(self)
        node.value.walkabout(self)
        self.visit_sequence(node.generators)

    def visit_GeneratorExp(self, node):
        node.elt.walkabout(self)
        self.visit_sequence(node.generators)

    def visit_Yield(self, node):
        if node.value:
            node.value.walkabout(self)

    def visit_Compare(self, node):
        node.left.walkabout(self)
        self.visit_sequence(node.comparators)

    def visit_Call(self, node):
        node.func.walkabout(self)
        self.visit_sequence(node.args)
        self.visit_sequence(node.keywords)
        if node.starargs:
            node.starargs.walkabout(self)
        if node.kwargs:
            node.kwargs.walkabout(self)

    def visit_Repr(self, node):
        node.value.walkabout(self)

    def visit_Num(self, node):
        pass

    def visit_Str(self, node):
        pass

    def visit_Attribute(self, node):
        node.value.walkabout(self)

    def visit_Subscript(self, node):
        node.value.walkabout(self)
        node.slice.walkabout(self)

    def visit_Name(self, node):
        pass

    def visit_List(self, node):
        self.visit_sequence(node.elts)

    def visit_Tuple(self, node):
        self.visit_sequence(node.elts)

    def visit_Const(self, node):
        pass

    def visit_Ellipsis(self, node):
        pass

    def visit_Slice(self, node):
        if node.lower:
            node.lower.walkabout(self)
        if node.upper:
            node.upper.walkabout(self)
        if node.step:
            node.step.walkabout(self)

    def visit_ExtSlice(self, node):
        self.visit_sequence(node.dims)

    def visit_Index(self, node):
        node.value.walkabout(self)

    def visit_comprehension(self, node):
        node.target.walkabout(self)
        node.iter.walkabout(self)
        self.visit_sequence(node.ifs)

    def visit_ExceptHandler(self, node):
        if node.type:
            node.type.walkabout(self)
        if node.name:
            node.name.walkabout(self)
        self.visit_sequence(node.body)

    def visit_arguments(self, node):
        self.visit_sequence(node.args)
        self.visit_sequence(node.defaults)

    def visit_keyword(self, node):
        node.value.walkabout(self)

    def visit_alias(self, node):
        pass


