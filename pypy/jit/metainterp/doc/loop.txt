========================================================================
                                 Loops
========================================================================


Basics
-----------------

*Loop Tree* = tree of operations.  Its root (i.e. start) corresponds to
a ``can_enter_jit`` marker, so it is when an application-level loop was
closed.  Its branches end in a JUMP back, corresponding to closing the
application-level loop.  The JUMPs themselves may go to the same or to
another loop tree, but for now we assume that all loop trees connected
in this way correspond to the same application-level loop.

We use Perfect Specialization to find out exactly how specialized each
loop should be.


Theory
-----------------

In theory, Perfect Specialization of a complete tree means the
following:

* find how much of the input arguments' structure is needed;
* find how much structure the output arguments have;
* do the intersection.

The input arguments' structure is the most precise structure that works
for all branches.  It describes how much information, at most, we would
like to have at the root.

The output arguments' structure is, similarly, the most precise
structure that correctly describes the output of all branches.  It
describes how much information, at most, we can pass to the next
iteration.

More precisely, we use the following *specnode* classes to represent
the level of specialization::

    .       VirtualSpec(cls, name1=spec1, ...)
                    |
         VirtualizableSpec(cls, name1=spec1, ...)
                    |
              FixedClassSpec(cls)
                    |
                 NotSpec

For (a simplified) example, ``VirtualizableSpec(PyFrame, x =
VirtualSpec(W_IntObject, value = NotSpec))`` describes the virtualizable
frame for a loop in which the only used variable is ``x``, which is a
virtual ``W_IntObject``.

The intersection rules are:

* the intersection of two ``VirtualSpec`` of the same ``cls`` is a
  further ``VirtualSpec``, and we proceed with the intersection of
  each field.

* the intersection of two ``VirtualizableSpec`` of the same ``cls`` is
  like the previous case, except that some names may be omitted
  completely from a given ``VirtualizableSpec``; in the case a name is
  present in only one of the ``VirtualizableSpec``, we just keep it
  unmodified in the intersection.

* in other cases, the result is ``FixedClassSpec`` if the two specnodes
  have the same class, or ``NotSpec`` if any is a ``NotSpec`` or if the
  two classes differ.
